[{"title":"数据结构和算法-链表实战之K个一组反转链表","date":"2019-08-06T05:31:30.000Z","path":"2019/08/06/数据结构和算法-链表实战-K个一组反转链表/","text":"链表实战题目5 - 反转链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 首先这里每组k个元素进行翻转，翻转之后每组需要进行衔接。例如[1, k]与[k+1,2k]之间的衔接。另外还需要注意剩余不到k个元素的处理。参考此链接。 方法一：迭代法:借助单链表翻转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" cur = head dim = ListNode(0) dim.next = head # pre为k个一组的头 pre = dim count = 1 while cur: # 每k个元素一组，对这里面的数据进行翻转 if count % k == 0: # 后面的一个k个一组的头节点 nextstart = cur.next # 前面的k个一组为新链表，以None结束 cur.next = None # 反转新链表，返回翻转后的头和尾，pre.next为翻转前的头节点。 end, start = self.reverseList(pre.next) \"\"\" 下面为衔接处理，pre前一个k个一组的尾节点 end指向下一个k个一组的头节点 现在的pre变为end cur变为nextstart \"\"\" pre.next, end.next, pre, cur = start, nextstart, end, nextstart else: cur = cur.next count += 1 return dim.next def reverseList(self, head): temp, cur, pre = head, head, None while cur: cur.next, pre, cur = pre, cur, cur.next # 以上的一句代码相当于如下的三句代码 # 当前节点指向前一个节点。这里实际上就是反转列表的第一步，将当前节点指向pre节点，即前一个节点初始值None # cur.next = pre # 这里是将当前节点赋给pre, 也就是当前节点变为了前一个节点 # pre = cur # 当前节点往后移动 # cur = cur.next return temp, pre 方法二：递归法递归终止条件：剩余节点 &lt; k。 递归从里向外出来，每层递归返回当前层级链表翻转后的头节点，那么每层递归中我们知道当前层级翻转后的头尾节点以及下一个k元素组的头节点（递归的上一层级），可以很轻松地将翻转后的链表衔接起来 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" if self.isEnd(head, k): return head pre = ListNode(None) pre.next, cur, count = head, head, 1 # 反转k个一组链表 while count &lt;= k: cur.next, pre, cur, count = pre, cur, cur.next, count + 1 # 循环结束后，cur指向下一组k个元素（未翻转）的头 # pre指向当前组在翻转后的头节点 # nexthead 下一组翻转后的头节点 nexthead = self.reverseKGroup(cur, k) # 当前组的head在翻转后成为尾节点，其next指向nexthead 下一组翻转后的头节点 head.next = nexthead # 返回翻转后的头节点 return pre # 递归终止的判断条件 def isEnd(self, head, k): count, cur = 0, head while cur: count += 1 cur = cur.next if count &gt;= k: return False return True 方法三：借助栈将k个元素压入栈，通过出栈翻转，注意剩余元素处理。参考这里。 12345678910111213141516171819202122232425class Solution(object): def reverseKGroup(self, head, k): dummy = ListNode(0) p = dummy while True: count = k stack = [] tmp = head while count and tmp: stack.append(tmp) tmp = tmp.next count -= 1 # 注意,目前tmp所在k+1位置 # 说明剩下的链表不够k个,跳出循环 if count : p.next = head break # 翻转操作 while stack: p.next = stack.pop() p = p.next #与剩下链表连接起来 p.next = tmp head = tmp return dummy.next","tags":[{"name":"数据结构和算法 链表实战 K个一组反转链表","slug":"数据结构和算法-链表实战-K个一组反转链表","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-K个一组反转链表/"}]},{"title":"数据结构和算法-环形链表II","date":"2019-08-06T01:30:00.000Z","path":"2019/08/06/数据结构和算法-链表实战-环形链表II/","text":"链表实战题目4 - 链表入环的第一个节点给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。进阶：你是否可以不用额外空间解决此题？ 方法一：直接法：哈希表此方法的空间复杂度为O(n)，并非最优，但是属于比较容易想到的方法。参考此链接。 12345678910111213141516171819class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head or not head.next: return None visited = set() p = head while p: visited.add(p) # 如果成环，那么当前节点的下一个在已经遍历过的节点集合内 if p.next in visited: # 返回这个下一个节点即可 return p.next p = p.next return None 方法二：快慢指针法使用一个快指针和一个慢指针，快指针每次都是走两步，慢指针每次都是走一步。如果二者可以相遇，即 fast == slow，那么代表链表中存在环。如果快指针走到了链表的尾部就会跳出循环，链表中无环。 当有环且快慢指针重合时，假设x为非环部分的长度，y为形成环路的位置到快慢指针重合位置的距离，z为快慢指针重合位置至形成环路位置之间的距离。重合时，慢指针行进的距离 = x + y；快指针行进的距离 = x + y + z + y。因为快指针的行走距离是慢指针的2倍，则有：2 * (x + y) = x + y + z + y。解得：x = z。 所以，通过在快慢指针重合的位置以及链表起始位置head，放置两个指针开始循环，每次两边各前进一个位置，当两者重合时的位置，就是链表形成环路的那个位置。参考此链接。 12345678910111213141516171819202122class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head or not head.next : return # 快慢指针 slow = head fast = head # 重新开始 start = head while fast and fast.next: slow = slow.next fast = fast.next.next # 找到相遇点 if slow == fast: while slow != start: slow = slow.next start = start.next return slow return None","tags":[{"name":"数据结构和算法 链表实战 环形链表 leetcode-142","slug":"数据结构和算法-链表实战-环形链表-leetcode-142","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-环形链表-leetcode-142/"}]},{"title":"数据结构和算法-链表实战之环形链表","date":"2019-08-05T11:30:00.000Z","path":"2019/08/05/数据结构和算法-链表实战-环形链表/","text":"链表实战题目3 - 判断是否是环形链表题目：给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 进阶篇：你能用 O(1)（即，常量）内存解决此问题吗？ 硬做的方法：如果没有环，那么应该会很快到达链表的尾节点。如果设置了时间范围，即如果1秒内仍然没有跳出来，说明应该有环。这种方法也是很直接。第二种方法是可以将遍历过的节点存储起来，如果当前节点的下一个节点在已经遍历过的节点集合内，说明有环。 方法一：直接法，哈希表这个很好考虑, 把遍历过的节点记录,当发现遍历的节点下一个节点遍历过, 说明有环。此方法的空间复杂度O(n)。 1234567891011121314class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" lookup = set() p = head while p: lookup.add(p) if p.next in lookup: return True p = p.next return False 直接法的时间和空间复杂度： 时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。 空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。 方法二：创建CheckNode这种方式会破坏链表结构，如果不在意这一点这个方法会很快。 此方法的具体思路：首先创建一个checkNode。遍历链表，将访问过的结点的next指向checkNode，如果存在环，有节点node1被访问过，则再次访问node1时，node1.next为checkNode。如果没有环，则永远访问不到checkNode。 这种方法的时间复杂度O(n),空间复杂度O(1), 1234567891011121314151617181920class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head is None: return False if head.next is None: return False CheckNode = ListNode(-1) while head: if head.next is CheckNode: return True new_head = head.next head.next = CheckNode head = new_head return False 方法三：快慢指针法此方法实际上是比较反人类的思维，不是很容易想到。 快慢指针的做法：设两指针fast slow指向链表头部head，迭代：fast每轮走两步，slow每轮走一步，这样两指针每轮后距离+1;若链表中存在环，fast和slow一定会在将来相遇（距离连续+1，没有跳跃）；若fast走到了链表尾部，则说明链表无环。 快慢指针法的时空复杂度分析： 因为只使用了快指针和慢指针两个节点，所以此方法的空间复杂度为O(1)。 时间复杂度的分析稍微复杂一些： （1）如果链表中不存在环：快指针将会首先到达尾部，其时间取决于列表的长度，也就是 O(n)O(n)。（2）如果链表中存在环：我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分： 慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中，即迭代次数 = 非环部分长度 = N。 两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为 1，因此需要经过（二者之间距离/速度差值）次循环之后，快指针可以追上慢指针。这个距离几乎就是环形部分长度K且速度差值为 1。我们得出这样的结论：迭代次数=近似于环形部分长度K。 因此，在最糟糕的情形下，时间复杂度为 O(N+K)，也就是O(n)。 12345678910111213141516# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): fast = slow = head while fast and fast.next: slow = slow.next fast = fast.next.next if fast is slow: return True return False","tags":[{"name":"数据结构和算法 链表实战 环形链表 leetcode-141","slug":"数据结构和算法-链表实战-环形链表-leetcode-141","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-环形链表-leetcode-141/"}]},{"title":"数据结构和算法-链表实战之两两交换链表中的节点","date":"2019-08-04T01:30:00.000Z","path":"2019/08/04/数据结构和算法-链表实战-两两交换列表中的元素/","text":"此题目依然对思维能力要求不高，而是对代码能力要求高。 链表实战题目2 - 两两交换链表中的节点题目：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 方法1: 使用迭代的思路解决此问题12345678910111213141516171819202122232425class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head cur, cur.next = self, head # cur.next以及cur.next.next都不为空时，执行交换。所以如果是有5个元素，那么最后只有一个元素时，就不满足cur.next.next不为空这个条件 while cur.next and cur.next.next: # a和b为要交换的两个节点 a = cur.next b = a.next a.next, b.next, cur.next = b.next, a, b # 交换a和b，此时cur.next发生了变化 # 将第一个节点指向第三个节点 # a.next = b.next # 第二个节点指向第一个节点 # b.next = a # 节点first指向第二个节点 # cur.next = b # 当前节点后移动，记得a.next是节点3，相当于跳了一个节点，往后移动了两个节点 cur = a return self.next 方法2: 使用递归的思路解决此问题参考此链接中的解法。另外具体递归过程的更详细解释可以参考此链接的动画图和注解。 1234567891011121314151617class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head cur = head # 下移两位之后，返回交换后两个节点中的前一个节点 nex = self.swapPairs(cur.next.next) # 交换两个节点 a, b = cur, cur.next a.next, b.next = nex, a return b 使用迭代解决问题时，先交换前两个，交换完成之后往下移动。而递归的思路是先往下移动，移动到最后再交换，交换完成的结果返回，而且返回的是b,也就是两个交换后节点的前一个。","tags":[{"name":"数据结构和算法 链表实战 两两交换链表中的节点 leetcode-24","slug":"数据结构和算法-链表实战-两两交换链表中的节点-leetcode-24","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-两两交换链表中的节点-leetcode-24/"}]},{"title":"数据结构和算法-链表实战之反转链表","date":"2019-08-03T00:31:30.000Z","path":"2019/08/03/数据结构和算法-链表实战-反转链表/","text":"基本上所有链表以及数据结构的题目，考察的并非思维能力，主要考察的是代码实现能力，对代码的简洁性有要求。 链表实战题目1 - 反转链表题目如下：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 方法一：反转链表最直接的思路就是转化为数组之后再生成链表但是此方法的空间复杂度比较高，时间复杂度也不好。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 首先判断链表是否为空，如果为空，那么直接返回退出 if not head or not head.next: return head # 将列表的值存储到数组visited中 visited = [] first = head while first: visited.append(first.val) first = first.next # 将数组转化为链表 # 首先使用ListNode生成head节点，也就是第一个节点 head = ListNode(visited.pop()) # 将第一个节点传递给last，然后接下来去生成last.next last = head # method 1 # # 终止条件就是列表为空 # while visited != []: # # last = head时，last.next = None,这时需要先去生成last.next # while last.next: # last = last.next # last.next = ListNode(visited.pop()) ## method 2 # while visited != []: last.next = ListNode(visited.pop()) last = last.next return head 方法二：使用迭代的方法进行因为反转列表是对链表中的每一个节点进行的操作，而终止信号时null，这就是典型的迭代。 下面这个代码实际上是错误的，参考[leetcode的解法][https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-zhi-chang-gui-si-lu-he-die-dai/]。 1234567891011121314151617181920# 这里是错误的代码# -*- coding:utf-8 -*-# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): cur, pre = head, None while cur: # 实际上将当前节点指向了laste节点 laste = cur.next # 再次又想将laste节点指向cur，如果想将laste节点指向cur，那么就相当于把laste节点和再下一个节点断开了。 laste.next=cur cur = cur.next return new_head 正确的迭代解法就是设置一个中间桥梁，也就是我们设置了一个前向指针pre, 然后去迭代。让当前节点指向前一个节点是第一步，cur.next = pre；前一个节点往后移动，即pre = cur；将当前节点后移是第三步, cur = cur.next。 12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5# 1指向2，2指向3，3指向4，4指向5# 2指向1，3指向2，4指向3，5指向5# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1class Solution(object): def reverseList(self, head): if not head or not head.next: return head cur, pre = head, None while cur: cur.next, pre, cur = pre, cur, cur.next # 以上的一句代码相当于如下的三句代码 # 当前节点指向前一个节点。这里实际上就是反转列表的第一步，将当前节点指向pre节点，即前一个节点初始值None # cur.next = pre # 这里是将当前节点赋给pre, 也就是当前节点变为了前一个节点 # pre = cur # 当前节点往后移动 # cur = cur.next return pre 另外需要注意的是，在最后退出while循环时，当前节点是5，5指向节点4，让pre为节点5，当前节点就是None, 不满足while循环的条件也就退出。退出时，pre代表节点5，所以最终返回的是pre。 方法三：使用递归解决此问题。通过调用函数本身即递归，实现反转链表。参考此[链接][https://zhuanlan.zhihu.com/p/60117407]。 123456789101112131415161718class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head if not head.next: print(head.val) return head headNode = self.reverseList(head.next) head.next.next = head head.next = None return headNode 首先, 函数进入开头的两个if语句，分别是用来判断当前节点和下一个节点是否为NULL，尤其是第二个,在后面递归过程中也会用到。 然后, 开始进入递归，注意传给 self.reverseList() 的参数为 head.next ,也就是说链表的会一直往后传递，直到找到最后一个节点（也就是head.val == 5的节点，后文简述为节点5）。此时，因为不满足第二个if语句，返回节点5。我们可以在第二个if语句中加入一行print( head.val )，这样可以更容易看出返回的内容。 123if not head.next: print(head.val) return head 紧接着，函数在第二步返回到递归的上一层，headNode等于返回的节点5 , 也就是节点5作为反转的链表头，完成反转的第一步。 当前节点head为节点4, head.next指向节点5， head.next.next 指向 None。 head.next.next = head 让原来指向None的节点5，改为指向节点4，完成了5—&gt;None到5—&gt;4的反转；然后head.next = None, 作用在于截断节点4到节点5的指针，避免形成4—&gt;5—&gt;4的环。 同理，返回上一层，当前节点head为节点3，让节点4指向节点3，再截断节点3到节点4的指针。如此重复，直到反转所有节点，headNode即为反转后的链表。","tags":[{"name":"数据结构和算法 链表实战 反转链表 leetcode-206","slug":"数据结构和算法-链表实战-反转链表-leetcode-206","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-反转链表-leetcode-206/"}]},{"title":"Hexo博客搭建过程","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/Hexo博客搭建过程/","text":"此次搭建博客主要参考的是这个视频! 整个搭建过程也很顺利，现将搭建过程总结如下： 切换到root用户首先需要输入如下代码： 1sudo su 这个命令，直接输入当前用户的密码即可切换到root用户。并且如果你的sudo设置而不需要输入密码，就直接切换到root用户了。 安装node.js,以及cnpm,并且使用cnpm安装hexo12345node -vnpm install -g cnpm --registryhttps://registry.npm.taobao.orgcnpm -vcnpm install -g hexo-clihexo -v 创建存储博客的文件夹，以下操作均是在这个文件夹下面进行, /Users/cailingling/Documents/blog123456sudo hexo init # 初始化hexo s # serverhexo n \"我的第一篇博客文章\"cd /Users/cailingling/Documents/blog/source/_posts/vi 我的第一篇博客文章.mdcd ../.. 本地查看博客123hexo clean # 清理缓存，把public缓存文件删除hexo generate # 生成新的public文件，该目录下的所有文件都是就是我们的github博客仓库的page页静态文件。可以简写为 \"hexo g\"hexo s # 会弹出来一个可以本地访问的网址：http://localhost:4000 将自己的博客部署到GitHub123cnpm install --save hexo-deployer-gitvi _config.yml hexo d # deploy （推上去），把public文件部署到github 修改主题为yilia, github.com/litten/hexo-theme-yilia123456git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliavi _config.yml # 将theme的landscape，修改为yilia啊hexo cleanhexo ghexo shexo d 这时再去即可查看更新后的博客主页。","tags":[{"name":"Hexo 博客搭建","slug":"Hexo-博客搭建","permalink":"http://yoursite.com/tags/Hexo-博客搭建/"}]},{"title":"数据结构和算法-复杂度分析(1)","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/数据结构和算法-复杂度分析(1)/","text":"这是我第一篇数据结构和算法的学习日志，主要为了加深自己对数据结构和算法的理解。我知道学任何东西都不会一步登顶，越是难以理解的东西越是需要自己慢慢积累沉淀。我将通过写博客的方式督促自己，并且方便自己学而时习之！多有不足，希望得到大家的批评指正！ 复杂度分析为什么要进行复杂度分析呢？当我们跑一遍程序，通过统计和监控也可以得到程序所需要的时间以及所占用的内存，此种方法存在很大的弊端，列举如下：（1）依赖测试环境，即不同配置的电脑或者服务器会有很大的区别。（2）数据规模的影响，数据规模过小时无法真实反应算法的性能。 大O复杂度表示法假设每行代码执行的时间为一个unit_time，所有代码的执行时间与每行代码的执行次数成正比。可以总结为如下的公式： T(n) = O(f(n))公式中的T(n)表示代码的执行时间，f(n)代表每行代码执行次数的总和，可以通过计算有多少个unit_time得到。公式中的O，表示代码的执行时间T(n)与f(n)成正比。例如 T(n) = O(2n+2)，T(n) = O(2n2+2n+3)。这就是大O时间复杂度表示法。它并不是指代码具体的执行时间，而是指代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度。 时间复杂度分析在分析一段代码的时间复杂度时，我们只需要关注这段代码中执行次数最多的那块代码。（1）加法法则：总复杂度等于量级最大的那段代码的复杂度。（2）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。 总结复杂度分析法则：1）单段代码看高频：比如循环。2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3）嵌套代码求乘积：比如递归、多重循环等4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 几种常见的时间复杂度将罗列的复杂度量级粗略分为两类：多项式量级和非多项式量级。（1）多项式量级：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）（2）随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）。 常见的复杂度量级：（1）O(1): 一般情况下，只要算法中不存在循环语句，递归语句，即使有成千上万行代码，复杂度也都是O(1)。（2）O(logn)、O(nlogn)：实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，时间复杂度都记为O(logn)，因为 对数之间是可以相互转换的，但是当我们采用大O计数法的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。如果一段代码的时间复杂度是 O(logn)，我们循环执行 n遍，那么这个算法的时间复杂度就是O(nlogn)。我们常见的归并排序和快速排序都是O(logn)。（3）O(m+n)、O(m*n)代码的复杂度有两个数据的规模决定，如果一段代码有两个代码块，一块的时间复杂度是o(m),另一块为O(n)，那么我们并不知道哪一块的数据规模更大，并不能省掉其中一个，此时我们就将其记为O(m+n)。原来的加法法则需要微调。 空间复杂度分析空间复杂度代表算法的存储空间和数据规模之间的增长关系。常见的空间复杂度就是 O(1)、O(n)、O(n2)。其余的像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。","tags":[{"name":"数据结构和算法 复杂度分析","slug":"数据结构和算法-复杂度分析","permalink":"http://yoursite.com/tags/数据结构和算法-复杂度分析/"}]},{"title":"数据结构和算法-复杂度分析(2)","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/数据结构和算法-复杂度分析(2)/","text":"本篇博客的主要内容就是四种时间复杂度以及一些分析复杂度的实例。 复杂度分析最好和最坏时间复杂度 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。 拿下面的查找函数find为例子，如果要查找的元素正好位于数组的第一个位置，那么时间复杂度就是O(1),如果要查找的元素正好位于最后一个，那么就是最坏时间复杂度O(n)。 平均时间复杂度平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。那么如何计算平均时间复杂度呢？ 因为要查找的变量x出现在数组中的位置可以有n+1种情况，最后这一种就代表要查找的元素不在此数组中。所以此时将每种情况下，查找元素需要遍历的元素个数累加即：1+2+3+…+n+n,然后除以n+1得到：((n+3)n)/(n+1),由此得到需要遍历元素个数的平均值。根据时间复杂度的大O计数法，可以省略系数、低阶和常量，所以就是O(n)。 123456789101112// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) &#123; pos = i; break; &#125; &#125; return pos;&#125; 但是前面计算平均时间复杂度是有一定的问题的，因为没有把每种情况会出现的概率考虑进去。首先，要查找的元素要么在数组中，要么不在数组中，在和不在的概率都是1/2；另外要查找的元素出现在0-n-1这n个位置中的概率也是一样的，即为1/n。那么根据概率乘法，要查找的元素出现在0-n-1的概率就是1/2n。因此平均时间复杂度就变为了： 11\\*(1/2n) + 2\\*(1/2n) + 3\\*(1/2n) + ... + n\\*(1/2n) + n \\* 1/2 = (3n + 1)/4 = O(n) 用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。 均摊时间复杂度均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 123456789101112131415161718// array 表示一个长度为 n 的数组// 代码中的 array.length 就等于 nint[] array = new int[n];int count = 0;void insert(int val) &#123; if (count == array.length) &#123; int sum = 0; for (int i = 0; i &lt; array.length; ++i) &#123; sum = sum + array[i]; &#125; array[0] = sum; count = 1; &#125; array[count] = val; ++count;&#125; 以上这段代码，是往数组中插入数据，最理想的情况就是数组中有空闲位置，此时插入到数组下标为count的位置就好，此时时间复杂度为O(1),最坏情况就是数组中没有空闲空间了，这时就需要做一次数组遍历求和，然后再将数据插入，此时是最坏时间复杂度O(n)。 此时如果去计算平均时间复杂度就是：插入数组的n个位置的时间复杂度为O(1),额外情况就是上面所说的O(n),而且这n+1种情况的发生概率一样。 11\\*(1/(n+1)) + 1\\*(1/(n+1)) + 1\\*(1/(n+1)) + ... + 1\\*(1/(n+1)) + n\\*(1/(n+1)) = O(1) 对比以上两个函数find()和insert()，对于find来说最优时间复杂度是O(1)，而对于insert()来说，大部分情况下时间复杂度都是O(1)。另外对于这里的insert()函数来说，并非一次操作，而是循环往复的操作，而且每一次O(n)的操作之后都会接着有n-1次O(1)的插入操作。所以就可以将耗时多的那次均摊到接下来的n-1次操作上。均摊下来，这一组连续操作的时间复杂度就是O(1)。这就是均摊时间复杂度。此种分析方法叫做摊还分析法。 均摊时间复杂度就是一种特殊的平均时间复杂度，而且二者的应用场景并不多。 一个分析实例add()函数如下： 12345678910111213141516171819202122// 全局变量，大小为 10 的数组 array，长度 len，下标 i。int array[] = new int[10]; // len并非确定量，只是初始值而已int len = 10;int i = 0;// 往数组中添加一个元素void add(int element) &#123; if (i &gt;= len) &#123; // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) &#123; new_array[j] = array[j]; &#125; // new_array 复制给 array，array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; &#125; // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i;&#125; 最好情况时间复杂度为 O(1) 最坏情况分析： 最坏情况代码执行的次数跟每次数组的长度有关 第1次调用insert的执行的次数为 n , 第2次调用insert的执行的次数为 2n , 第3次调用insert的执行的次数为 2^2 * n 第k次调用insert的执行的次数为 2^(k-1) * n 最坏时间复杂度为 O(n)。 平均情况分析 当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0len-1, len(2len-1),….； 插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1， 最后求出加权平均时间复杂度为 1p + 2p+ ▪▪▪ + len*p + len * p = O(1) ; 均摊时间复杂度 O(1) 均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)","tags":[{"name":"数据结构和算法 复杂度分析","slug":"数据结构和算法-复杂度分析","permalink":"http://yoursite.com/tags/数据结构和算法-复杂度分析/"}]},{"title":"Hello World","date":"2019-08-02T02:51:21.877Z","path":"2019/08/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]