[{"title":"数据结构和算法-链表实战之环形链表","date":"2019-08-05T11:30:00.000Z","path":"2019/08/05/数据结构和算法-链表实战-环形链表/","text":"链表实战题目3 - 判断是否是环形链表题目：给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 进阶篇：你能用 O(1)（即，常量）内存解决此问题吗？ 方法一：快慢指针法设两指针fast slow指向链表头部head，迭代：fast每轮走两步，slow每轮走一步，这样两指针每轮后距离+1;若链表中存在环，fast和slow一定会在将来相遇（距离连续+1，没有跳跃）；若fast走到了链表尾部，则说明链表无环。此方法的空间复杂度为O(1) 123456789101112131415161718# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if fast == slow: return True return False 方法二：直接法：哈希表这个很好考虑, 把遍历过的节点记录,当发现遍历的节点下一个节点遍历过, 说明有环。此方法的空间复杂度O(n)。 1234567891011121314class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" lookup = set() p = head while p: lookup.add(p) if p.next in lookup: return True p = p.next return False 方法三：创建CheckNode首先创建一个checkNode。遍历链表，将访问过的结点的next指向checkNode，如果存在环，有节点node1被访问过，则再次访问node1时，node1.next 为checkNode。如果没有环，则永远访问不到checkNode。时间复杂度O(n),空间复杂度O(1),这种方式会破坏链表结构，如果不在意这一点这个方法会很快。 1234567891011121314151617181920class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head is None: return False if head.next is None: return False CheckNode = ListNode(-1) while head: if head.next is CheckNode: return True new_head = head.next head.next = CheckNode head = new_head return False","tags":[{"name":"数据结构和算法 链表实战 环形链表 leetcode-141","slug":"数据结构和算法-链表实战-环形链表-leetcode-141","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-环形链表-leetcode-141/"}]},{"title":"数据结构和算法-链表实战之两两交换链表中的节点","date":"2019-08-04T01:30:00.000Z","path":"2019/08/04/数据结构和算法-链表实战-两两交换列表中的元素/","text":"链表实战题目2 - 两两交换链表中的节点题目：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 方法1: 使用迭代的思路解决此问题12345678910111213141516171819202122232425262728293031class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head cur, cur.next = ListNode(0), head first = cur # cur.next以及cur.next.next都不为空时，执行交换。所以如果是有5个元素，那么最后只有一个元素时，就不满足cur.next.next不为空这个条件 while cur.next and cur.next.next: # n1和n2为要交换的两个节点 n1 = cur.next n2 = n1.next nex = n2.next # 交换n1和n2，此时cur.next发生了变化 # 将第一个节点指向第三个节点 n1.next = nex # 第二个节点指向第一个节点 n2.next = n1 # 节点first指向第二个节点 cur.next = n2 # n1.next, n2.next, cur.next = next, n1, n2 # 当前节点后移动，记得n1.next是节点3，相当于跳了一个节点，往后移动了两个节点 cur = n1 return first.next 方法2: 使用递归的思路解决此问题参考此链接中的解法。另外具体递归过程的更详细解释可以参考此链接的动画图和注解。 123456789101112131415161718class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head cur = head # 下移两位之后，返回交换后两个节点中的前一个节点 nex = self.swapPairs(cur.next.next) # 交换两个节点 n1, n2 = cur, cur.next n1.next, n2.next = nex, n1 return n2 使用迭代解决问题时，先交换前两个，交换完成之后往下移动。而递归的思路是先往下移动，移动到最后再交换，交换完成的结果返回，而且返回的是n2,也就是两个交换后节点的前一个。","tags":[{"name":"数据结构和算法 链表实战 两两交换链表中的节点","slug":"数据结构和算法-链表实战-两两交换链表中的节点","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-两两交换链表中的节点/"}]},{"title":"数据结构和算法-链表实战之反转链表","date":"2019-08-03T00:31:30.000Z","path":"2019/08/03/数据结构和算法-链表实战-反转链表/","text":"链表实战题目1 - 反转链表题目如下：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 方法一：反转链表最直接的思路就是转化为数组之后再生成链表。但是此方法的空间复杂度比较高，时间复杂度也不好。12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" # 首先判断链表是否为空，如果为空，那么直接返回退出 if not head or not head.next: return head # 将列表的值存储到数组res_origin中 res_origin = [] first = head while first: res_origin.append(first.val) first = first.next # 将数组转化为链表 # 首先使用ListNode生成head节点，也就是第一个节点 head = ListNode(res_origin.pop()) # 将第一个节点传递给last，然后接下来去生成last.next last = head # method 1 # # 终止条件就是列表为空 # while res_origin != []: # # last = head时，last.next = None,这时需要先去生成last.next # while last.next: # last = last.next # last.next = ListNode(res_origin.pop()) ## method 2 # while res_origin != []: last.next = ListNode(res_origin.pop()) last = last.next return head 方法二：使用迭代的方法进行。因为反转列表是对链表中的每一个节点进行的操作，而终止信号时null，这就是典型的迭代。下面这个代码实际上是错误的，参考[leetcode的解法][https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-zhi-chang-gui-si-lu-he-die-dai/]。 123456789101112131415161718192021# 这里是错误的代码# -*- coding:utf-8 -*-# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head): current_node, pre = head, None while current_node: # 实际上将当前节点指向了laste节点 laste = current_node.next # 再次又想将laste节点指向current_node，如果想将laste节点指向current_node，那么就相当于把laste节点和再下一个节点断开了。 laste.next=current_node current_node = current_node.next return new_head 正确的迭代解法就是设置一个中间桥梁，也就是我们设置了一个前向指针pre, 然后去迭代。让当前节点指向前一个节点是第一步，cur.next = pre；前一个节点往后移动，即pre = cur；将当前节点后移是第三步, cur = cur.next。 12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5# 1指向2，2指向3，3指向4，4指向5# 2指向1，3指向2，4指向3，5指向5# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1class Solution(object): def reverseList(self, head): if not head or not head.next: return head current_node, pre = head, None while current_node: current_node.next, pre, current_node = pre, current_node, current_node.next # # 以上的一句代码相当于如下的三句代码 # 当前节点指向前一个节点。这里实际上就是反转列表的第一步，将当前节点指向pre节点，即前一个节点初始值None # current_node.next = pre # 这里是将当前节点赋给pre, 也就是当前节点变为了前一个节点 # pre = current_node # 当前节点往后移动 # current_node = current_node.next return pre 另外需要注意的是，在最后退出while循环时，当前节点是5，5指向节点4，让pre为节点5，当前节点就是None, 不满足while循环的条件也就退出。退出时，pre代表节点5，所以最终返回的是pre。 方法三：使用递归解决此问题。通过调用函数本身即递归，实现反转链表。参考此[链接][https://zhuanlan.zhihu.com/p/60117407]。 123456789101112131415161718class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head if not head.next: print(head.val) return head headNode = self.reverseList(head.next) head.next.next = head head.next = None return headNode 首先, 函数进入开头的两个if语句，分别是用来判断当前节点和下一个节点是否为NULL，尤其是第二个,在后面递归过程中也会用到。 然后, 开始进入递归，注意传给 self.reverseList() 的参数为 head.next ,也就是说链表的会一直往后传递，直到找到最后一个节点（也就是head.val == 5的节点，后文简述为节点5）。此时，因为不满足第二个if语句，返回节点5。我们可以在第二个if语句中加入一行print( head.val )，这样可以更容易看出返回的内容。 123if not head.next: print(head.val) return head 紧接着，函数在第二步返回到递归的上一层，headNode等于返回的节点5 , 也就是节点5作为反转的链表头，完成反转的第一步。 当前节点head为节点4, head.next指向节点5， head.next.next 指向 None。 head.next.next = head 让原来指向None的节点5，改为指向节点4，完成了5—&gt;None到5—&gt;4的反转；然后head.next = None, 作用在于截断节点4到节点5的指针，避免形成4—&gt;5—&gt;4的环。 同理，返回上一层，当前节点head为节点3，让节点4指向节点3，再截断节点3到节点4的指针。如此重复，直到反转所有节点，headNode即为反转后的链表。","tags":[{"name":"数据结构和算法 链表实战 反转链表","slug":"数据结构和算法-链表实战-反转链表","permalink":"http://yoursite.com/tags/数据结构和算法-链表实战-反转链表/"}]},{"title":"Hexo博客搭建过程","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/Hexo博客搭建过程/","text":"此次搭建博客主要参考的是这个视频! 整个搭建过程也很顺利，现将搭建过程总结如下： 切换到root用户首先需要输入如下代码： 1sudo su 这个命令，直接输入当前用户的密码即可切换到root用户。并且如果你的sudo设置而不需要输入密码，就直接切换到root用户了。 安装node.js,以及cnpm,并且使用cnpm安装hexo12345node -vnpm install -g cnpm --registryhttps://registry.npm.taobao.orgcnpm -vcnpm install -g hexo-clihexo -v 创建存储博客的文件夹，以下操作均是在这个文件夹下面进行, /Users/cailingling/Documents/blog123456sudo hexo init # 初始化hexo s # serverhexo n \"我的第一篇博客文章\"cd /Users/cailingling/Documents/blog/source/_posts/vi 我的第一篇博客文章.mdcd ../.. 本地查看博客123hexo clean # 清理缓存，把public缓存文件删除hexo generate # 生成新的public文件，该目录下的所有文件都是就是我们的github博客仓库的page页静态文件。可以简写为 \"hexo g\"hexo s # 会弹出来一个可以本地访问的网址：http://localhost:4000 将自己的博客部署到GitHub123cnpm install --save hexo-deployer-gitvi _config.yml hexo d # deploy （推上去），把public文件部署到github 修改主题为yilia, github.com/litten/hexo-theme-yilia123456git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliavi _config.yml # 将theme的landscape，修改为yilia啊hexo cleanhexo ghexo shexo d 这时再去即可查看更新后的博客主页。","tags":[{"name":"Hexo 博客搭建","slug":"Hexo-博客搭建","permalink":"http://yoursite.com/tags/Hexo-博客搭建/"}]},{"title":"数据结构和算法-复杂度分析(2)","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/数据结构和算法-复杂度分析(2)/","text":"本篇博客的主要内容就是四种时间复杂度以及一些分析复杂度的实例。 复杂度分析最好和最坏时间复杂度 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。 拿下面的查找函数find为例子，如果要查找的元素正好位于数组的第一个位置，那么时间复杂度就是O(1),如果要查找的元素正好位于最后一个，那么就是最坏时间复杂度O(n)。 平均时间复杂度平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。那么如何计算平均时间复杂度呢？ 因为要查找的变量x出现在数组中的位置可以有n+1种情况，最后这一种就代表要查找的元素不在此数组中。所以此时将每种情况下，查找元素需要遍历的元素个数累加即：1+2+3+…+n+n,然后除以n+1得到：((n+3)n)/(n+1),由此得到需要遍历元素个数的平均值。根据时间复杂度的大O计数法，可以省略系数、低阶和常量，所以就是O(n)。 123456789101112// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) &#123; pos = i; break; &#125; &#125; return pos;&#125; 但是前面计算平均时间复杂度是有一定的问题的，因为没有把每种情况会出现的概率考虑进去。首先，要查找的元素要么在数组中，要么不在数组中，在和不在的概率都是1/2；另外要查找的元素出现在0-n-1这n个位置中的概率也是一样的，即为1/n。那么根据概率乘法，要查找的元素出现在0-n-1的概率就是1/2n。因此平均时间复杂度就变为了： 11\\*(1/2n) + 2\\*(1/2n) + 3\\*(1/2n) + ... + n\\*(1/2n) + n \\* 1/2 = (3n + 1)/4 = O(n) 用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。 均摊时间复杂度均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 123456789101112131415161718// array 表示一个长度为 n 的数组// 代码中的 array.length 就等于 nint[] array = new int[n];int count = 0;void insert(int val) &#123; if (count == array.length) &#123; int sum = 0; for (int i = 0; i &lt; array.length; ++i) &#123; sum = sum + array[i]; &#125; array[0] = sum; count = 1; &#125; array[count] = val; ++count;&#125; 以上这段代码，是往数组中插入数据，最理想的情况就是数组中有空闲位置，此时插入到数组下标为count的位置就好，此时时间复杂度为O(1),最坏情况就是数组中没有空闲空间了，这时就需要做一次数组遍历求和，然后再将数据插入，此时是最坏时间复杂度O(n)。 此时如果去计算平均时间复杂度就是：插入数组的n个位置的时间复杂度为O(1),额外情况就是上面所说的O(n),而且这n+1种情况的发生概率一样。 11\\*(1/(n+1)) + 1\\*(1/(n+1)) + 1\\*(1/(n+1)) + ... + 1\\*(1/(n+1)) + n\\*(1/(n+1)) = O(1) 对比以上两个函数find()和insert()，对于find来说最优时间复杂度是O(1)，而对于insert()来说，大部分情况下时间复杂度都是O(1)。另外对于这里的insert()函数来说，并非一次操作，而是循环往复的操作，而且每一次O(n)的操作之后都会接着有n-1次O(1)的插入操作。所以就可以将耗时多的那次均摊到接下来的n-1次操作上。均摊下来，这一组连续操作的时间复杂度就是O(1)。这就是均摊时间复杂度。此种分析方法叫做摊还分析法。 均摊时间复杂度就是一种特殊的平均时间复杂度，而且二者的应用场景并不多。 一个分析实例add()函数如下： 12345678910111213141516171819202122// 全局变量，大小为 10 的数组 array，长度 len，下标 i。int array[] = new int[10]; // len并非确定量，只是初始值而已int len = 10;int i = 0;// 往数组中添加一个元素void add(int element) &#123; if (i &gt;= len) &#123; // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) &#123; new_array[j] = array[j]; &#125; // new_array 复制给 array，array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; &#125; // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i;&#125; 最好情况时间复杂度为 O(1) 最坏情况分析： 最坏情况代码执行的次数跟每次数组的长度有关 第1次调用insert的执行的次数为 n , 第2次调用insert的执行的次数为 2n , 第3次调用insert的执行的次数为 2^2 * n 第k次调用insert的执行的次数为 2^(k-1) * n 最坏时间复杂度为 O(n)。 平均情况分析 当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0len-1, len(2len-1),….； 插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1， 最后求出加权平均时间复杂度为 1p + 2p+ ▪▪▪ + len*p + len * p = O(1) ; 均摊时间复杂度 O(1) 均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)","tags":[{"name":"数据结构和算法 复杂度分析","slug":"数据结构和算法-复杂度分析","permalink":"http://yoursite.com/tags/数据结构和算法-复杂度分析/"}]},{"title":"数据结构和算法-复杂度分析(1)","date":"2019-08-02T08:08:24.000Z","path":"2019/08/02/数据结构和算法-复杂度分析(1)/","text":"这是我第一篇数据结构和算法的学习日志，主要为了加深自己对数据结构和算法的理解。我知道学任何东西都不会一步登顶，越是难以理解的东西越是需要自己慢慢积累沉淀。我将通过写博客的方式督促自己，并且方便自己学而时习之！多有不足，希望得到大家的批评指正！ 复杂度分析为什么要进行复杂度分析呢？当我们跑一遍程序，通过统计和监控也可以得到程序所需要的时间以及所占用的内存，此种方法存在很大的弊端，列举如下：（1）依赖测试环境，即不同配置的电脑或者服务器会有很大的区别。（2）数据规模的影响，数据规模过小时无法真实反应算法的性能。 大O复杂度表示法假设每行代码执行的时间为一个unit_time，所有代码的执行时间与每行代码的执行次数成正比。可以总结为如下的公式： T(n) = O(f(n))公式中的T(n)表示代码的执行时间，f(n)代表每行代码执行次数的总和，可以通过计算有多少个unit_time得到。公式中的O，表示代码的执行时间T(n)与f(n)成正比。例如 T(n) = O(2n+2)，T(n) = O(2n2+2n+3)。这就是大O时间复杂度表示法。它并不是指代码具体的执行时间，而是指代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度。 时间复杂度分析在分析一段代码的时间复杂度时，我们只需要关注这段代码中执行次数最多的那块代码。（1）加法法则：总复杂度等于量级最大的那段代码的复杂度。（2）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。 总结复杂度分析法则：1）单段代码看高频：比如循环。2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3）嵌套代码求乘积：比如递归、多重循环等4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 几种常见的时间复杂度将罗列的复杂度量级粗略分为两类：多项式量级和非多项式量级。（1）多项式量级：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）（2）随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）。 常见的复杂度量级：（1）O(1): 一般情况下，只要算法中不存在循环语句，递归语句，即使有成千上万行代码，复杂度也都是O(1)。（2）O(logn)、O(nlogn)：实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，时间复杂度都记为O(logn)，因为 对数之间是可以相互转换的，但是当我们采用大O计数法的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。如果一段代码的时间复杂度是 O(logn)，我们循环执行 n遍，那么这个算法的时间复杂度就是O(nlogn)。我们常见的归并排序和快速排序都是O(logn)。（3）O(m+n)、O(m*n)代码的复杂度有两个数据的规模决定，如果一段代码有两个代码块，一块的时间复杂度是o(m),另一块为O(n)，那么我们并不知道哪一块的数据规模更大，并不能省掉其中一个，此时我们就将其记为O(m+n)。原来的加法法则需要微调。 空间复杂度分析空间复杂度代表算法的存储空间和数据规模之间的增长关系。常见的空间复杂度就是 O(1)、O(n)、O(n2)。其余的像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。","tags":[{"name":"数据结构和算法 复杂度分析","slug":"数据结构和算法-复杂度分析","permalink":"http://yoursite.com/tags/数据结构和算法-复杂度分析/"}]},{"title":"Hello World","date":"2019-08-02T02:51:21.877Z","path":"2019/08/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]